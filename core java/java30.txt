Thread priority
===============
In java, every thread has a priority explicitly provided by the programmer or automatically generated by JVM.

The valid range of thread priority is 1 to 10. Where 1 is a least priority and 10 is a highest priority.

If we take more then 10 priority then we will get IllegalArgumentException.

Thread class defines following standard constants as thread priorities.
ex:
	Thread.MAX_PRIORITY - 10
	Thread.MIN_PRIORITY  - 1
	Thread.NORM_PRIORITY - 5

We don't have such constants like LOW_PRIORITY and HIGH_PRIORITY.

A thread which is having highest priority will be executed first.

Thread schedular uses thread priority while allocating to CPU.

We have following methods to set and get thread priorities.
ex:
	public final void setPriority(int priority)
	public final int getPriority()

ex:
---
class MyThread extends Thread 
{

}
class Test  
{
	public static void main(String[] args) 
	{
		System.out.println(Thread.currentThread().getPriority());//5

		MyThread t=new MyThread();
		System.out.println(t.getPriority());//5

		Thread.currentThread().setPriority(9);
		System.out.println(Thread.currentThread().getPriority());//9

		t.setPriority(4);
		System.out.println(t.getPriority());//4
	}
}

Various ways to prevent a thread from execution
===============================================
There are three ways to prevent a thread from execution.

1) yield()

2) join()

3) sleep() 



1) yield()
---------
It pause the current execution thread and gives the chance to other threads having same priority.

If there is no waiting threads or low priority threads then same thread will continue it's execution.

If multiple waiting threads having same priority then we can't expect any execution order.

A thread which is yielded when it will get a chance for execution is depends upon mercy of thread schedular.

ex:
	public static native void yield()

Diagram: java30.1

ex:
---
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			Thread.currentThread().yield();
			System.out.println("Child-Thread");
		}
	}
}
class Test  
{
	public static void main(String[] args) 
	{
		MyThread t=new MyThread();

		t.start();

		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}


2) join()
----------
If a thread wants to waiting untill the completion of some other thread then we need to use join() method.

A join() method will throw one checked exception called InterruptedException so we must and should handle that exception by using try and catch block or by using throws statement.

ex:
	public final void join()throws InterruptedException 
	public final void join(long ms)throws InterruptedException 
	public final void join(long ms,int ns)throws InterruptedException 
	
Diagram: java30.2


class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test  
{
	public static void main(String[] args)throws InterruptedException
	{
		MyThread t=new MyThread();
		t.start();
		t.join();
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

3) sleep()
--------------
If a thread don't want to perform any operation on perticular amount of time then we need to use sleep() method.

A sleep() method will throw on checked exception called InterruptedException so we must and should handle that exception by using try and catch block or by using throws statement.

ex:
	public static native void sleep()throws InterruptedException 
	public static native void sleep(long ms)throws InterruptedException 
	public static native void sleep(long ms,int ns)throws InterruptedException 
	
Diagram: java30.3


class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class Test  
{
	public static void main(String[] args)
	{
		MyThread t=new MyThread();
		t.start();
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}



Problem without synchronization 
===============================
If we don't have synchronization then we will face following problems.

1) Data inconsistency 

2) Thread interference 

ex:
---
class Table  
{
	void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class MyThread1 extends Thread 
{
	Table  t;
	MyThread1(Table  t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	Table  t;
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Table obj=new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);

		t1.start();
		t2.start();
	}
}



synchronization
================
A synchronized keyword is applicable for methods and blocks.

A synchronization is allowed one thread to execute given object.Hence we achieve thread safety.

The main advantage of synchronization is we solve data inconsistence problem.

The main disadvantage of synchronization is ,it will increase waiting time of a thread which reduce the performance of the system.

If there is no specific requirement then it is never recommanded to use synchronization concept.

synchronization internally uses lock mechanism.

Whenever a thread wants to access object , first it has to acquire lock of an object and thread will release the lock when it completes it's task.

When a thread wants to execute synchronized method.It automatically gets the lock of an object.

When one thread is executing synchronized method then other threads are not allowed to execute other synchronized methods in a same object concurently.But other threads are allowed to execute non-synchronized method concurently.

ex:
class Table
{
	synchronized void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
				System.out.println(n*i);
				try
				{
					Thread.sleep(2000);
				}
				catch (InterruptedException ie)
				{
					ie.printStackTrace();
				}
		}
	}
}
class MyThread1 extends Thread
{
	Table t;
	MyThread1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}

class MyThread2 extends Thread
{
	Table t;
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}
}

class Test 
{
	public static void main(String[] args)
	{
		Table obj=new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);

		t1.start();
		t2.start();
	}
}

synchronized block
====================
If we want to perform synchronization on specific resource of a program then we need to use 
synchronization.

ex:
	If we have 100 lines of code and if we want to perform synchronization only for 
	10 lines then we need to use synchronized block.

If we keep all the logic in synchronized block then it will act as a synchronized method.

ex:
class Table
{
	 void printTable(int n)
	{
		synchronized(this)
		{
		for(int i=1;i<=5;i++)
		{
				System.out.println(n*i);
				try
				{
					Thread.sleep(2000);
				}
				catch (InterruptedException ie)
				{
					ie.printStackTrace();
				}
		}
		}//sync
	}
}
class MyThread1 extends Thread
{
	Table t;
	MyThread1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}

class MyThread2 extends Thread
{
	Table t;
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}
}

class Test 
{
	public static void main(String[] args)
	{
		Table obj=new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);

		t1.start();
		t2.start();
	}
}



3)Static synchronization
=====================
In static synchronization the lock will be on class but not on object.

If we declare any static method as synchronized then it is called static synchronization method.

ex:
class Table
{
	static synchronized void printTable(int n)
	{
	
		for(int i=1;i<=5;i++)
		{
				System.out.println(n*i);
				try
				{
					Thread.sleep(2000);
				}
				catch (InterruptedException ie)
				{
					ie.printStackTrace();
				}
		}
		
	}
}
class MyThread1 extends Thread
{
	
	public void run()
	{
		Table.printTable(5);
	}
}

class MyThread2 extends Thread
{

	public void run()
	{
		Table.printTable(10);
	}
}

class Test 
{
	public static void main(String[] args)
	{
		
		MyThread1 t1=new MyThread1();
		MyThread2 t2=new MyThread2();

		t1.start();
		t2.start();
	}
}

Inter-Thread Communication
===========================
Two threads can communication by using wait(), notify() and notifyAll() method.

A thread which is waiting for notification has to call wait() method and a thread which is giving notification has to call notify() or notifyAll() method.

A wait(), notify() and notifyAll() methods of Object class but not Thread class.

To invoke wait(), notify() and notifyAll() method compulsory we required synchronized area othewise we will get IllegalStateMonitorException.

A thread which calls wait() method on a current object then it will release the lock of that object immediately and it goes waiting state.

A thread which calls notify() And notifyAll() method on a current object then it will release the lock of that object but not immediately.

Except wait(), notify() and notifyAll() method there is no way to release the lock.

ex:
---
class MyThread extends Thread 
{
	int total=0;

	public void run()
	{
		synchronized(this)
		{
			System.out.println("Child started Calculation");
			
			for(int i=1;i<=10;i++)
			{
				total+=i;
			}

			System.out.println("Child Giving notification");
			this.notify();
		}
	}
}
class Test 
{
	public static void main(String[] args)throws InterruptedException 
	{
		MyThread t=new MyThread();
		t.start();

		synchronized(t)
		{
			System.out.println("Main method is waiting");
			t.wait();
			System.out.println("Main method got notification");
			System.out.println(t.total);//55
		}
	}
}

DeadLock 
=========
Deadlock will occur in a situation where one thread is waiting for object lock which is acquired by another thread and that thread is waiting for object lock is which acquired by first thread. Here both the threads are ready to release lock but nobody will release. This situation is called DeadLock.

Diagram: java44.1

class Test 
{
	public static void main(String[] args)
	{
		final String res1="hi";
		final String res2="bye";

		//Anonymous inner class
		Thread t1=new Thread()
		{
			public void run()
			{
				synchronized(res1)
				{
					System.out.println("Thread1: Locking Resource1");
					synchronized(res2)
					{
						System.out.println("Thread1: Locking Resource2");
					}
				}
			}
		};

		//Anonymous inner class
		Thread t2=new Thread()
		{
			public void run()
			{
				synchronized(res2)
				{
					System.out.println("Thread2: Locking Resource2");
					synchronized(res1)
					{
						System.out.println("Thread2: Locking Resource1");
					}
				}
			}
		};

		t1.start();
		t2.start();
	}
}

























































